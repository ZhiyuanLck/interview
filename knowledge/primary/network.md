# 计算机网络

## 网络模型

1. OSI七层网络模型
    1. 物理层，通过媒介透明地传输比特流，指定连接器、数据速率和如何在某些介质
       上进行编码。
    1. 数据链路层，物理寻址，同时将原始比特流转变为逻辑传输线路，指定通过单一
       链路通信的方法。ARP地址解析协议，PPTP点对点隧道协议。
    1. 网络层，指定经过潜在不同类型链路层网络的多跳通信方法，对于分组网络，它
       描述了抽象的分组格式和标准编址结构。网际协议IP，网际控制消息协议ICMP，
       ICMPv6，网际组管理协议IGMP
    1. 传输层，接收上一层的数据，必要的时候对数据进行分割，并将数据交给网络层。
       传输控制协议TCP，用户数据协议UDP。
    1. 会话层，指定由多个连接组成一个通信会话的方法。安全套接字协议SSL，传输层
       安全协议TSL，远程过程调用协议RPC。
    1. 表示层，指定对应用数据表示格式和转换规则的方法。比如外部数据表示协议XDP
    1. 应用层，各种用户协议，指定某些用户初始化任务的方法。超文本传输协议HTTP，
       文件传输协议FTP，简单邮件传输协议SMTP，动态主机配置协议DHCP，DNS域名系
       统

1. 其他协议分层

    5层协议：物理层，链路层，网络层，传输层，应用层

    被TCP/IP采用的ARPANET模型：网络访问层，网际互连层，传输层，应用层

## IP地址

1. IPv4地址空间分类寻址
    - A类：0开头，8位网络号，24位主机
    - B类：10开头，16位网络号，16位主机
    - C类：110开头，24位网络号，8位主机
    - D类：1110开头，组播地址
    - E类：1111开头，保留

1. 子网掩码

    子网掩码是由一台主机或路由器使用的分配位，以确定如何从一台主机对应IP地址获
    得网络和子网信息。子网掩码与对应的IP地址的长度相同，一个IP地址可以与子网掩
    码进行按位与操作，形成用于路由地址的网络/子网标识符（前缀）

1. 可变子网掩码VLSM

    大多数主机、路由器和路由协议支持VLSM，VLSM用于分割一个网络号，使每个子网支
    持不同数量的主机。

1. 子网广播地址

    子网广播地址通过将IPv4地址的网络/子网部分设置为适当值，主机部分所有位设置
    为1而形成。通过子网掩码取反，然后与IP地址进行按位或操作形成。广播地址可用
    于IPv4中，IPv6仅使用组播地址。

1. 无类别域间路由CIDR

    通过CIDR掩码，未经过预定义的任何地址范围可作为一个类的部分，消除了一个IP地
    址中网路和主机号的预定义分隔。

1. 组播地址

    IPv4和IPv6都支持组播寻址。一个IP组播地址标识一组主机接口而不是单个主机接口。
    一个组所覆盖的网络部分成为组的范围。常见范围包括节点本地（同一计算机）、链
    路本地（同一子网）、站点本地和全球。

    当一台主机向一个组发送数据时，使用单播IP地址作为源地址，使用组播IP地址作为
    目的地址，已加入组的所有主机将接收发送到该组的任何数据报。

## 链路层

1. 以太网帧大小

    以太网帧最小为64字节，有效载荷最小为48字节，不够时填充。传统以太网最大帧长
    度是1518字节，包括4字节CRC和14字节头部，剩下的是1500字节的MTU

1. 链路层流量控制

    以太网使用PAUSE消息实现流量控制，由802.3x定义。PAUSE消息包含在MAC控制帧中，
    通过将以太网长度/类型字段值设为0x8808，以及使用MAC控制操作码0x0001来标识，
    如果一个站接收到这种帧，表示建议它减缓发送。PAUSE帧总是被发送到固定的MAC地
    址，且只能在全双工链路上使用。它包含一个保持关闭（hold-off）时间值，表明发
    送方在继续发送之前需要暂停多长时间。

1. 网桥和交换机

    交换机本质是高性能的网桥，网桥或交换机用于连接多个物理的链路层网络组成的站。

1. 生成树协议STP

    STP通过在每个网桥禁用某些端口来工作，这样可以避免拓扑环路。

1. 无线局域网协议

    IEEE 802.11(Wi-Fi)

1. 点到点协议

    PPP表示点到点协议，是一种子串行链路上传输IP数据包的流行方法。PPP实际上是一
    个协议集合，它支持建立链接的基本方法，链路控制协议LCP，以及一系列网络控制
    NCP协议，在LCP建立了基本链路后，用于为各种协议建立网络层链路。

1. ARP

    地址解析协议ARP提供了一种在IPv4地址和各种网络技术使用的硬件地址之间的映射。
    ARP仅用于IPv4

1. ARP直接交付

    直接交付发生在一个IP数据包被发送到一个具有相同IP前缀的IP地址的情况下。

    1. 每个主机会在自己的ARP缓冲区建立一个ARP列表，表示IP地址和MAC地址之间的对
       应关系
    1. 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC
       地址，如果有，则直接发送数据，如果没有，就向共享的链路层网段中的所有主
       机发送一个被称为ARP请求的以太网帧，该数据包包括的内容有：源主机IP地址，
       源主机MAC地址，目的主机的IP地址。这也被称为链路层广播。
    1. 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己
       的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机
       的IP地址和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC
       地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
    1. 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息
       发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

## IP

1. IPv4数据报

    20字节基本头部和最多40字节的选项（4位头部长度），IPv4数据包最大为65535字节
    （16位总长度），但主机不需要接收超过576字节的IPv4数据包，超过这个限制会对
    数据报进行分片。

    前4个字节包括，版本字段，头部长度，DS字段，ECN，和总长度；第二个字用于分片，
    包括标识，标志和分片偏移；第三个字包括生存期，协议和头部校验和；之后是源IP
    地址，目的IP地址和选项。

1. IPv6数据报

    IPv6头部大小是固定的40字节，包括版本、DS字段、ECN、流标签、负载长度、下一
    个头部、跳数限制、源IP地址和目的IP地址。IPv6头部不支持分片，分片是通过扩展
    头部完成的。

1. IPv4 vs. IPv6

    [详细区别](https://www.ibm.com/docs/zh/i/7.2?topic=6-comparison-ipv4-ipv6)
    - IPv4地址为32位，IPv6地址为128位，IPv6支持更大的寻址空间
    - IPv4地址用点来分割字段，IPv6地址用冒号来分割字段
    - IPv4头部大小在20-60字节，IPv6头部中没有IP报头选项，头部大小为 40字节，但
      IPv6通过扩展头部实现了更多选项
    - IPv4数据报最大为576字节，IPv6为至少1280字节
    - IPv6移除了头部校验和
    - IPv4支持VLSM，IPv6不支持VLSM而是使用类似CIDR的分层结构
    - IPv4使用ARP将IP地址映射到MAC地址，IPv6使用ICMPv6将这些功能嵌入到IP本身作
      为无状态自动配置和邻节点发现算法的一部分。
    - 分片：IPv4中如果一个信息包对于要传送它的下一链路来说太大，那么可由发送方
      （主机或路由器）对其分段。对于 IPv6，只能在源节点进行分段，且只能在目标
      节点完成重新装配。使用分段扩展报头。

1. 转发表

    转发表每个条目包含目的地、掩码、下一跳和接口。目的地用于与一个掩码操作的结
    果相匹配。

1. IP转发

    取出数据报中的目的IP地址，在转发表中执行最长前缀匹配算法，即搜索所有与目的
    IP地址进行掩码操作后与转发条目目的地相等的条目，选择最匹配的条目（掩码中有
    多少位设置为1，1的数量越多匹配度越高），将其下一跳字段作为转发数据报的下一
    跳IP地址。

## DNS

1. DNS解析的过程

    1. 当主机通过一个浏览器访问一个URL时，主机上的解析器软件首先向它的本地名称
       服务器发送DNS请求报文，要求将域名转换为对应的IP地址。
    1. 本地名称服务器一般也是一台缓存/转发服务器，收到请求后它先查询本地缓存，
       如果缓存中有相应记录则将查询结果返回给主机，否则向ISP提供的DNS服务器发
       送解析请求，这一步称为递归请求。
    1. ISP提供的DNS服务进行与本地DNS服务器相同的工作，如果没有在本地缓存中查找
       到对应记录，则向根名称服务器发送解析请求。
    1. 根名称服务器是非递归的，不会进一步处理请求，而是返回需要联系的授权服务
       器的名称和IP地址。
    1. ISP提供的DNS服务器根据返回的信息去联系这些通用顶级域名服务器，即进行迭
       代查询，直到返回域名授权的名称服务器的名称和IP地址
    1. ISP提供的DNS服务器联系该名称服务器，获得域名对应的IP地址，将其记录入缓
       存然后返回给本地名称服务器。
    1. 本地名称服务器同样更新缓存，然后将期望的IP地址回复给客户端。

## UDP

1. 可靠UDP

    一般有两种途径，一种是基于ARQ（Automatic Repeat reQuest）的确认和重传机制，
    一种是使用前向纠错（FEC）

## TCP

1. TCP如何实现可靠性

    - 数据包校验，TCP头部中有针对整个数据包的校验和
    - 对失序数据包重新排序
    - 丢弃重复数据
    - 应答机制
    - 超时重传
    - 流量控制

1. TCP vs. UDP

    - TCP面向连接，传输数据之前需要建立会话，UDP是无连接的
    - TCP提供可靠传输，保证数据不丢包、不重复且按序到达；UDP只尽努力交付，不保
      证可靠交付
    - TCP面向字节流，没有消息边界，UDP面向报文，有消息边界
    - TCP提供了流量控制和拥塞控制，UDP不提供
    - TCP只支持点到点通信，UDP支持一对一，一对多，多对多。
    - TCP首部开销大需要20字节，UDP首部只有8字节

1. TCP粘包

    指发送放发送的若干包数据到达接收方时粘成了一个包，从接收缓冲区来看，后一包
    数据的头紧接着前一包数据的尾。出现粘包的原因可能是多方面的：
    1. 发送方使用了Nagle算法，将多次间隔较小、数据量较小的数据合并成一个数据量
       大的数据块，然后进行封包。解决方法，使用TCP_NODELAY选项来关闭算法。
    1. 接收方收到数据包存入缓存的速度大于应用程序从缓存中读取数据包的速度，多
       个包就会被缓存。接收方无法解决这个问题

    设计一个带包头的应用层报文结构，包头定长，以特定标志开头，里面带有负载长度。

1. 2MSL

    服务端发送FIN后需要收到客户端的ACK才能确认对方已经收到连接即将关闭的信号。
    最坏情况下，客户端回复的ACK丢失，需要等待服务端重传FIN，去向ACK的最大存活
    时间加上来向FIN的最大存活时间为2MSL，即2MSL至少允许报文丢失一次，1MSL只能
    确保客户端最后发送的ACK以及之前可能延时的报文消失，连接断开后可能还会收到
    重传的FIN，与新TCP连接中的报文冲突。

1. time_wait状态的连接过多的危害，如何优化

    time_wait状态结束前，本地端口号一直被占用，当所有可用端口号被占用后，无
    法创建新的连接

    可以通过设置内核参数

    1. `net.ipv4.tcp_syncookies = 1` 表示开启SYN Cookies。当出现SYN等待队列溢出
       时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
    1. `net.ipv4.tcp_tw_reuse = 1` 重用处于time_wait状态的连接
    1. `net.ipv4.tcp_tw_recycle = 1` 快速回收处于time_wait状态的连接，启用回收
       时，服务器无法区分来自同一台NAT设备的不同客户端的即将传入的连接
    1. `net.ipv4.tcp_fin_timeout =`  修改系统默认的 TIMEOUT 时间
    1. `net.ipv4.tcp_max_tw_buckets = 5000` 表示系统同时保持TIME_WAIT套接字的
       最大数量，(默认是18000). 当TIME_WAIT连接数量达到给定的值时，所有的
       TIME_WAIT连接会被立刻清除，并打印警告信息。但这种粗暴的清理掉所有的连接，
       意味着有些连接并没有成功等待2MSL，就会造成通讯异常。一般不建议调整
    1. `net.ipv4.tcp_timestamps = 1` (默认即为1)开启时间戳
    1. `net.ipv4.ip_local_port_range = 1024 65535` 增加可用端口范围
    1. 调整短连接为长连接


1. SYN泛洪

    一个或多个恶意的客户端使用伪造的源IP地址产生一系列TCP连接尝试即SYN报文段，
    并将它们发送给一台服务器。服务器会为每一条连接分配一定数量的连接资源，由于
    连接没有完全建立，服务器在维护了大量半打开的连接后会耗尽自身的内存并拒绝为
    后续的合法连接服务。

    1. 增加积压队列的容量，即增加系统允许的可能半开连接的最大数量
    1. 回收最早的半开连接，这要求合法的连接在积压队列被填满前完全建立连接
    1. SYN cookies，与连接相关的大部分信息存储被编码存储在SYN+ACK报文段的序列
       号中，系统不需要为新的连接请求分配存储资源，只有当SYN+ACK报文段被确认后
       才分配真正的内存。


### 拥塞控制

1. 拥塞窗口检验（Congestion Window Validation, CWV）

    CWV是为了解决发送端在一定时间内停止发送而导致cwnd无法准确反映路径中的拥塞
    情况。当需要发送新数据时，首先看距离上次发送操作是否超过一个RTO，如果超过
    则更新ssthresh值为max(ssthresh, 3/4 * cwnd)，然后每经过一个空闲RTT时间，
    cwnd值减半但不小于1SMSS，这样在长时间暂停后，发送方会进入慢启动阶段。

1. 二进制增长拥塞控制BIC

    - 最小窗口：最近一次在一个完整RTT中没有出现丢包的窗口大小
    - 最大窗口：最近一次出现丢包时的窗口大小
    - 二分搜素增大：选取最小窗口和最大窗口的中间值作为试验窗口，如果仍然丢包则
      更新最大窗口，否则更新最小窗口，直到最大窗口与最小窗口的差值小于最小增量
      S_min
    - 加法增大：当中间点与当前窗口大小之间的差值大于窗口夹S_max的时候，增量被
      限制为每个RTT增加S_max。
    - 二进制增长：当检测到丢包时，窗口会使用乘法系数β来减小，窗口增大时首先使
      用加法增大算法，之后一旦确认加法增量小于S_max就转为使用二分搜索增大算法。
      当窗口增长超过当前最大值，或者由于还没有丢包发生而没有已知的最大值时，增
      长会终止。

1. CUBIC

    CUBIC改进了BIC在一些情况下增长过快的不足，并对窗口增长机制进行了简化。它不
    像BIC使用阈值来决定何时使用加法增大和二分搜索增大，而是使用一个高阶多项式
    函数（一个三次方程）来控制窗口的增大。

    W(t) = C(t - K)^3 + W_max

    - W(t)表示时刻t的窗口大小
    - C是一个常量
    - t是距离最近一次窗口减小所经过的时间，
    - K = (βW_max / C)^(1/3)是在没有丢包的情况下从W增长到W_max所用的时间
    - W_max是最后一次调整前的窗口大小

    当发生快速重传时，W_max = cwnd，而新的cwnd和ssthresh被设置为β*cwnd

1. 基于延迟的Vegas算法

    Vegas算法测量每个RTT中传输的数据量，用这个数除以网络中观察到的最小延迟时间。
    算法维护了两个阈值a和b（a < b），当吞吐量（窗口大小除以观测到的最小RTT）与
    预期不符时，若得到的吞吐量小于a，则将拥塞窗口变大，若大于b，则将拥塞窗口减
    小，在两者之间则维持不变。反向拥塞会导致算法出问题

    其他算法还有FAST，Westwood，Westwood++，复合TCP（CTCP）

1. 积极队列管理和ECN

    缓存队列中的数据如果占用的队列时间超过最小值，且小于最大值，则数据包会被标
    记上一个不断增长的概率值，如果占用时间超过了最大值，会被标记一个最大概率或
    者丢弃。当数据包被接收时，拥塞标记表明这个包经过了一个拥塞的路由器，接收端
    向发送端返回一个ACK数据包来通知拥塞状况。

    ECN主要在IP层操作，包含ECN功能的路由器发生长时间拥塞时，会查看IP数据包中的
    ECN传输能力（ECT）标识，如果有效，负责发送数据包的传输层协议将开启ECN功能，
    此时路由器会在IP头设置一个已发生拥塞（CE）标识（将ECN都置为1），然后转发数
    据报。TCP实现了一个小型的可靠连接协议，通过这个协议可以将拥塞标识返回给发
    送段，即TCP接收端接收到CE标识被置位的数据包后，会将每一个ACK数据包的ECN回
    显字段置位，直到接收到一个从发送端发来的CWR字段被置位的数据包。

## HTTP

1. GET vs. POST

    1. GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源
    1. GET不会改变服务器上的资源，POST会对服务器资源进行改变
    1. GET请求的数据会附在URL之后，POST请求会将提交的数据放置在请求体中，POST
       安全性更高
    1. GET请求的长度受限于URL长度限制，POST请求没有大小限制

1. HTTP各个版本的区别

    1. HTTP/0.9，HTTP最早的版本，只有一种请求方法GET，不支持，服务器只能响应
       HTML格式的数据。具有无状态性，每个事务独立处理，事务结束时就释放这个连
       接。
    1. HTTP/1.0，第一个在通讯中指定版本号的HTTP协议版本
        - 支持请求头与响应头，每个通信必须包含头部
        - 增加了POST, PUT, HEAD, DELETE, LINK, UNLINK请求方式
        - 通过Content-Type字段可以发送和响应更多格式的数据
        - 短连接，每次请求建立一个TCP连接，响应后立马断开
    1. HTTP/1.1
        - 增加了OPTION, TRACE, CONNET请求方法
        - 持久连接，建立1次TCP连接后进行多次请求和响应的交互
        - 管线化，从前发送请求后需要等待收到响应后才能发送下一个请求，管线化使
          得不用等待响应也可以直接发送下一个请求
        - 分块传输编码，将实体主体分成多个部分，每一块用十六进制来标记块的大小，
          由接收的客户端解码。能让浏览器逐步显示页面
        - 缓存控制
        - 内容协商，包括语言，编码或类型
        - Host字段，识别同一IP地址下的多个主机
        - 字节范围请求，支持传送内容的一部分，通过Content-Range实现，如果相应
          地返回了对象请求范围的内容，则相应码为206 Partial Content
    1. HTTP/2.0
        - 二进制分帧，在不改动HTTP语义的情况下改进传输性能，实现低延迟和高吞吐
          量。首部信息被封装到Headers帧，body被封装到Data帧，采用二进制格式的
          编码。
        - 多路复用，并行处理多个请求
        - 随时复位，通过RST_STREAM可以方便的停止一个信息传输，启动新的信息
        - 压缩头部
        - 请求优先级
        - server push, 服务器可以主动推送数据

1. 队头阻塞head of line blocking

    每个浏览器/客户端与服务器的连接数量有限，通过其中的连接进行新的请求必须等
    待这些连接完成之前的请求。

## Socket

1. Socket相关函数

    - `socket`创建一个socket描述符
    - bind
    - listen
    - accept
    - connect
    - send，sendto
    - recv，recvfrom
