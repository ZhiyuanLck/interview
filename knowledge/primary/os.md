# 操作系统

## 进程

1. 进程和线程的区别

    - 进程是一个正在执行程序的实例，是资源调度的基本单位，用于实现操作系统的并发；
      线程也可以看做轻量级的进程，是CPU调度的基本单位
    - 进程拥有一个或多个线程，线程只属于一个进程
    - 进程在执行过程中拥有独立的虚拟内存空间，因此进程间是相互隔离的；同一进程中的
      不同线程共享当前进程的内存空间和所有的资源，这些线程间是没有保护的，一个线程
      甚至可以访问另一个线程的堆栈和地址
    - 每个进程在进程表中有对应的表项，里面存储着进程管理相关字段，比如寄存器、程序
      计数器、程序状态字、堆栈指针、程序状态等，存储管理相关字段，比如代码段指针、
      数据段指针、堆栈段指针等，文件管理相关字段，比如工作目录、文件描述符、用户ID
      等；用户级线程每个进程中都有一张线程表，所有内核级线程都记录在一张内核中的线
      程表，由于线程共享它所属于的进程的所有资源，进程表表项中只记录程序计数器、寄
      存器、堆栈、线程状态等内容。
    - 进程的创建和撤销需要为其分配或回收资源，比如内存空间，I/O设备，打开的文件的
      等等，而线程基本不持有资源而是直接共享来自进程的资源，因此进程的创建和撤销开
      销更大；进程间的切换同样比线程间的切换开销更大，这主要是因为切换进程时需要同
      步切换页表和虚拟内存，这会使TLB中对应的缓存失效从而降低了命中率，从而使虚拟
      地址转换为物理地址的过程变慢。
    - 同一进程间不同线程的由于共享同一虚拟内存空间使得它们的通信更加容易，而进程间
      的通信则需要专门的手段，比如消息传递、共享内存等
    - 进程间不会相互影响，而一个线程阻塞或挂掉会导致整个进程阻塞或挂掉

1. 进程的切换过程

1. 线程的切换过程

1. 进程间通信
    1. 管道（消息传递）
        - 由`pipe`函数创建，返回两个文件描述符，一个只能读，另一个只能写，即提
          供一个半双工的单向数据流
        - 管道也可以是全双工的，此时它由两个半双工管道组成。
        - 管道只能用于具有亲缘关系的进程之间通信
        - 管道是一种特殊的文件，只存在于内存中
    1. FIFO命名管道（消息传递）
        - FIFO是一个单向数据流，FIFO有路径名与之关联，因此可以用于无亲缘关系进
          程之间的通信
    1. 消息队列
        - 消息队列可以看做一个消息链表，拥有足够权限的进程才可以在队列中放置消
          息或者从队列中取走消息
        - 每个消息都是一个记录，它由发送者赋予一个优先级
        - 消息队列具有随内核的持续性，管道最后一次关闭发生时，管道中的数据将被
          丢弃，而消息队列是独立于发送与接收进程的，进程终止不会导致消息被删除
        - 允许异步事件通知，通过产生一个信号或者创建一个线程执行指定的函数
    1. 信号，用于通知接收进程某个事件已经发生
    1. 共享内存
        - 通过`mmap`函数使多个进程可以访问同一块内存空间
        - 共享内存是IPC中最快的，因为进程间的数据传递无需再通过内核传递
        - 信号量通常和共享内存一起使用用来同步不同进程对共享内存的访问
    1. 套接字：TCP套接字、UDP套接字、UNIX域套接字

1. 线程同步
    1. 互斥锁，用来保护临界区，保证任意时刻只有一个线程在执行其中的代码。互斥
       锁只能用来上锁不能用来等待
    2. 条件变量：`pthread_cond_signal`函数用来唤醒等待在相应条件变量上的一个线
       程或者用`pthread_cond_broadcast`唤醒阻塞在相应条件变量上的所有线程
    3. 读写锁
        - 获取一个读写锁用于读叫做共享锁，其他线程也可以读
        - 获取一个读写锁用于写叫做独占锁，其他线程不能访问或修改
    4. 记录上锁，可用于进程间共享某个文件的读与写，应用会指定文件中待上锁或解
       锁的字节范围
    5. 信号量，用于提供不同进程间或一个给定进程的不同线程间同步手段的原语，通
       过原子的PV操作来增加或减少信号量
        - `sem_wait`函数测试信号量的值，如果大于0就减一并返回，否则使线程处于
          休眠状态
        - 线程使用完某个信号量调用`sem_post`使该信号量的值加1
    6. 屏障，当一个进程到达屏障时会被屏障拦住，直到所有进程都到达该屏障为止

1. `fork`和`vfork`的区别
    - 一个进程可以调用`fork`函数创建一个新的进程，`fork`函数被调用一次会返回两
      次，子进程的返回值是0（一个子进程只有一个父进程，可以通过`getpid`获得父
      进程的进程ID，而ID 0总是由内核交换进程使用），父进程的返回值是新建子进程
      的进程ID。然后子进程和父进程继续执行`fork`调用后的指令。子进程是父进程的
      副本，获得父进程数据空间、堆和栈的副本。现在很多实现使用了写时复制(COW)
      技术，数据段、堆栈由父进程和子进程共享，而且内核将它们的访问权限变为只读。
      如果父进程和子进程中的任意一个试图修改这些区域，内核只为修改区域的那块内
      存制作一个副本，通常是虚拟内存的一页。
    - `vfork`用于创建一个新进程来执行一个新程序。`vfork`创建一个子进程但是不会
      把父进程的地址空间完全复制到子进程中，因为子进程会立即调用`exec`从而不会
      引用该地址空间。在调用`exec`之前，子进程在父进程的空间中运行。`vfork`保
      证子进程先运行，在调用`exec`或`exit`后父进程才可能被调度运行。o

1. `wait`和`waitpid`的作用
    - 如果其所有的子进程都还在运行，则阻塞
    - 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程状态立即
      返回
    - 如果没有子进程，出错返回
    - `waitpid`可使调用者不阻塞，且并不等待其调用第一个终止的子进程

## 内存

1. 什么是虚拟内存
