# 数据库

## 索引

1. 聚集索引

    聚集索引按照每张表的主键构造一颗B+树，叶子节点中存放的是整张表的行记录数据。
    叶子节点间通过双向链表连接。聚集索引对主键的排序和范围查找非常快。

1. 辅助索引

    辅助索引的叶子节点并不包括行记录的全部数据。叶子节点中除了键值外，每个叶子
    节点中的索引行中还包含一个指向对应行数据的聚集索引键的书签。

    通过辅助索引来寻找数据时，InnoDB会遍历辅助索引并通过叶级别的指针获得指向主
    键索引的主键，然后通过聚集索引来找到一个完整的行记录。

1. 添加B+树索引的原则

    在访问表中很少一部分数据时建立索引才有意义，可以通过show index结果列中的
    Cardinality的值来观察该索引是否有高选择性，Cardinality表示索引中不重复记录
    数量的预估值。Cardinality/n_rows_in_table应尽可能接近1

1. 联合索引

    联合索引是指对表上的多个列进行索引。对a、b列或者a列的查询可以使用(a, b)索
    引，对b列的查询则不可以，因为叶子节点上的b值不是有序的。联合索引可以避免多
    次排序。

1. 覆盖索引

    指从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖
    索引的好处是辅助索引不包含整行记录的所有信息，大小远小于聚集索引。比如查询
    count(*)可以选择辅助索引较少IO操作。

    范围查找和join链接查找一般会使用聚集索引。

1. Multi-Range Read（MRR）优化

    MRR的目的是为了减少磁盘的随机访问，将其转换为较为顺序的数据访问。对于
    InnoDB和MyISAM的范围查询和join查询有

    - 将查询得到的辅助索引键值存放于一个缓存中
    - 将缓存中的键值按照RowID进行排序
    - 根据RowID的排序顺序来访问实际的数据文件

    MRR的好处有

    - 使数据访问变得较为顺序
    - 减少缓冲池中页被替换的次数
    - 批量处理对键值的查询操作

1. Index Condition Pushdown (ICP)优化

    不开启ICP进行索引查询时，首先根据索引查找记录，然后根据where条件来过滤记录。
    开启ICP后，会在取出索引的同时，判断是否可以进行where条件的过滤，即将where
    的部分过滤操作放在了存储引擎层，在某些查询下，大大减少了上层SQL层对记录的
    索取。

1. 自适应hash索引

    数据库自身创建并使用，DBA本身不能进行干预。自适应hash索引经hash函数映射到
    一个hash表中，对字典类型的查找非常迅速。

1. 全文检索

    全文检索是将存储与数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。
    通常使用倒排索引实现，它在辅助表中存储了单词与单词自身在一个或多个文档中所

    - inverted file index, {单词，单词所在文档ID}
    - full inverted index，{单词，(单词所在文档ID，在文档中具体位置)}

## 锁

1. InnoDB的存储引擎锁

    InnoDB提供一致性的非锁定读和行级锁支持。行级锁没有额外的开销，且可以同时得
    到并发性与一致性。

1. lock与latch的区别

    latch是轻量级的锁，锁定的时间必须非常短，否则应用的性能会很差。InnoDB中，
    latch可以分为mutex互斥量和rwlock读写锁。其目的是用来保证并发线程操作临界资
    源的正确性，并且通常没有死锁检测机制。

    lock的对象是事务，用来锁定数据库中的对象比如表、页、行。一般lock只在事务
    commit或rollback后释放。lock有死锁检测和处理机制。

1. 行级锁

    InnoDB中实现了两种标准行级锁，共享锁和排他锁，只有共享锁之间是兼容的，共享
    锁和排他锁，排他锁和排他锁之间不兼容。共享锁允许事务读一行数据，排他锁允许
    事务删除或更新一行数据。

1. 意向锁

    InnoDB支持多粒度锁定，允许事务在行锁和表所同时存在。这种所称为意向锁，即将
    锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上加锁。对细粒度的对
    象上锁，需要等待对粗粒度的对象上锁完成。

    InnoDB中意向锁为表锁，主要目的是为了在一个事务中揭示下一行将被请求的类型，
    分为

    - 意向共享锁，事务想要获得一张表中某几行的共享锁
    - 意向排他锁，事务想要获得一张表中某几行的排他锁

    意向锁不会阻塞除全表扫以外的任何请求。

## Redis

1. 缓存穿透

    缓存穿透是指查询一定不在缓存中存在的数据会直接去数据库查询，如果有大量这样
    的请求，缓存的作用就会失效。

    - 把无效的key也存进redis中
    - 使用布隆过滤器，当布隆过滤器判断元素不在缓存中，则一定不在

1. 缓存击穿

    缓存击穿是一个热点的key，被超高并发地访问，然后这个key突然失效了，导致并发
    请求直接打到数据库上

    - 对热点key不设置过期时间
    - 使用互斥锁，缓存失效时只有拿到锁才能查询数据库

1. 缓存雪崩

    某一时刻出现大规模的缓存失效时，大量的请求会直接到达数据库，高并发的情况下
    可能会导致数据库宕机。

    解决方案：

    - 在原有的失效时间上加上一个随机值，避免采用相同的过期时间导致缓存雪崩
    - 使用熔断机制，当流量到达一定阈值时，返回“系统拥挤”之类的提示，防止数据库
      同时接收过多请求
    - 提高数据库容灾能力，采取分库、分表，读写分离的策略。
