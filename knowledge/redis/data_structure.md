# Redis数据结构

## 简单动态字符串SDS

1. 定义

    - int len; 记录buf数组中字符串的长度不包括\0
    - int free; 记录buf数组中未使用字节的数量
    - char buf[]; 字节数组，用来保存字符串

1. 与C字符串的区别

    - 常数复杂度获取字符串长度
    - 杜绝缓冲区溢出，SDS先检查空余空间，必要是进行扩容
    - 减少修改字符串时带来的内存重分配次数，C字符串拼接和截断都需要重分配内存

1. SDS空间分配策略

    1. 空间预分配，用于优化SDS的字符串增长操作，减少连续执行字符串增长操作所需
       的内存重分配次数，当需要扩容时
        - 如果修改后SDS的长度小于1MB，分配和len属性同样大小的未使用空间
        - 如果修改后SDS的长度大于1MB，分配1MB的未使用空间
    1. 惰性空间释放，用于优化SDS的字符串缩短操作，缩短SDS时，不立即收回空余出
       来的内存，而是用修改free属性记录多余的字节

## 链表

1. Redis链表特性

    - 双向无环链表，表头prev指针和表尾next指针指向NULL
    - 有表头和表尾指针
    - 有链表长度计数器
    - 用`void*`指针保存节点值，可以保存各种不同类类型的值

## 字典

1. 字典

    字典保存键值对，其中每个键都是唯一的。

1. 底层hash表实现

    hash表结构

    - `dictEntry **table;` hash表数组
    - unsigned long size; hash表大小
    - unsigned long sizemask; 掩码，用来计算索引值，总是等于size-1
    - unsigned long used; 已有节点的数量

    hash表节点属性

    - `void* key;` 键
    - union v; 值，保存一个`void*`指针，或者一个`uint64_t`整数或`int64_t`整数
    - `dictEntry* next;` 指向下一个节点，形成链表，开链法解决冲突

    dict结构

    - `dictType *type` 保存hash函数和操作键值的函数
    - `void* private` 保存需要传递给类型特定函数的可选参数
    - `dictht ht[2]` 两个hash表，第二个只在rehash时使用
    - `int rehashindex` 记录了rehash目前的进度，没有进行rehash时值为-1

1. hash算法

    Redis使用MurmurHash算法o

1. rehash步骤

    将负载因子维持在一个合理的范围，hash表保存的键值对数量太多或太少时，程序需
    要对hash表的大小进行扩展或收缩并进行rehash

    1. 为ht[1]哈希表分配空间，空间大小取决于要执行的操作以及ht[0]中的键值对数
       量`ht[0].used`
        - 如果是扩展，则ht[1]的大小为第一个大于等于`ht[0].used * 2`的2的幂
        - 如果是收缩，则ht[1]的大小为第一个大于等于`ht[0].used`的2的幂
    1. 将`ht[0]`中所有键值对rehash到`ht[1]`中
    1. 释放`ht[0]`将`ht[1]`设置为`ht[0]`并在`ht[1]`新建空白的hash表

    rehash的时机

    - 服务器没有在执行BGSAVE或BGREWRITEAOF命令，且负载因子大于1，自动进行扩展
    - 服务器正在在执行BGSAVE或BGREWRITEAOF命令，且负载因子大于5，自动进行扩展
    - 负载因子小于0.1，自动进行收缩

1. 渐进式rehash

    1. 为`ht[1]`分配空间
    1. 将`rehashindex`设为0，表示rehash开始进行
    1. 在rehash期间，每次对字典执行添加、删除、查找或更新操作时，程序除了执行
       指定的操作，还顺带将rehashidx索引上的所有键值对rehash到`ht[1]`，并将
       `rehashindex`加1
    1. rehash完成后将`rehashidx`设为-1表示rehash已完成

    渐进式rehash过程中，字典同时使用两个表，且添加操作只将元素添加到`ht[1]`

## 跳跃表skiplist

跳跃表是一种有序数据结构，通过在节点中维护多个指向其他节点的指针，达到快速访问
节点的目的。支持平均O(log N)，最坏O(N)复杂读的节点查找，还可以通过顺序性操作来
批量处理节点。

Redis中跳跃表用来实现有序集合键，以及在集群节点中用作内部数据结构。

1. 缓存穿透

    缓存穿透是指查询一定不在缓存中存在的数据会直接去数据库查询，如果有大量这样
    的请求，缓存的作用就会失效。

    - 把无效的key也存进redis中
    - 使用布隆过滤器，当布隆过滤器判断元素不在缓存中，则一定不在

1. 缓存击穿

    缓存击穿是一个热点的key，被超高并发地访问，然后这个key突然失效了，导致并发
    请求直接打到数据库上

    - 对热点key不设置过期时间
    - 使用互斥锁，缓存失效时只有拿到锁才能查询数据库

1. 缓存雪崩

    某一时刻出现大规模的缓存失效时，大量的请求会直接到达数据库，高并发的情况下
    可能会导致数据库宕机。

    解决方案：

    - 在原有的失效时间上加上一个随机值，避免采用相同的过期时间导致缓存雪崩
    - 使用熔断机制，当流量到达一定阈值时，返回“系统拥挤”之类的提示，防止数据库
      同时接收过多请求
    - 提高数据库容灾能力，采取分库、分表，读写分离的策略。
